## Non-Decimal numeric bases

```rust
    let hexa = 0x10;
    let decimal = 10;
    let octal = 0o10;
    let binary = 0b10;
```

- This will print: "16 10 8 2" it s so because, if a literal integer number starts with a zero digit followed by an "x"(that is the third letter of "hexadecimal) that number is expressed in hexadecimal motation; instead, if it starts with a zero followed by an "o"(that is the initial of "octal"), it is a number expressed in octal notation; and instead, if it start with a zero followed by a "b" (that is the initial of "binary"), it is a number expressed in binary notation.

## The Exponential Notation

```rust
    let on_thousand = 1e3;// 10 ^ 3
```

## Unsigned Integer

- It comes out that the efficient type to use as index of an array or of a vector, the index of an array or vector should be unsigned, and it should have the same size of memory address. Notice that it is not relevant on which system the compiler runs, but on which system the program generated by the compiler will run. Actually, by a so-called "cross-compilation", a compiler can generate machine code for a system having a different architecture from the one where the compiler is run. The system for which machine code is generated is named "target". So there is a need to specify an integer numeric type system, and a 64-bit integer if the target is an 64-bit system.

- In the word *usize*, the "u" letter indicates it is an unsigned integer, and the "size" word indicates it is a type thought to measure the length of some (possibly very large) object.
- The compiler implements the *usize* type as the u32 type, if it is generating machine code for a 32-bit system, while implements it as the u64 type, if it is generating machine code for a 64-bit system.

## Type Inference
```rust
    let a = [0];
    let i = 0;
    print!("{}", a[i]);
```

- Each variable and each expression has always a well-defined type, but it is not always required to specify explicitly such a type, In many cases, the compiler is able to deduce it, or, as it is usually said, *infer* it, from the way in which the variable or expression in question is used.
- For instance, in the preceding example, after having assigned to "i" the integer value 0, the compiler infers that ype of "i" must be that of an integer number, but it has not yet determined exactly which one, among the ten integer types available in Rust. We say that type of such variable is that of a generic, or better, unconstrained, integer number.
- However, when the compile realizes that such vairable is used to index an array, an operation allowed only to the *usize* type, the compiler assigns the *usize* to the "i" variable, as it is the only allowed type.
